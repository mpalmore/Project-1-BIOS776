---
title: "Project_1"
author: "Meredith Palmore"
date: "9/13/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Set directory, load required packages, and import data

```{r load}

here()

library(tidyverse)

#install.packages("tidytuesdayR")

tuesdata <- tidytuesdayR::tt_load('2020-01-21')

spotify_songs <- tuesdata$spotify_songs

glimpse(spotify_songs)

head(spotify_songs)

```

# Part 1: Explore data

### 1. How many songs are in each genre?

```{r genre}

genres <- spotify_songs %>% group_by(playlist_genre) 

summarize(genres, "total_songs" = length(track_id))


```
See the above output for the number of songs per genre.

### 2. What is the average value of energy and acousticness in the latin genre in this dataset?

```{r summarize_genres}
genres %>% filter(playlist_genre == "latin") %>% summarize("avg_energy"=mean(energy), "avg_acousticness"=mean(acousticness))


```

The average value of energy is about 0.71 on a scale of 0 to 1. 
The average value of acousticness is about 0.21 on a scale of 0 to 1. 

### 3. Calculate the average duration of song (in minutes) across all subgenres. Which subgenre has the longest song on average?

```{r summarize_duration}

subgenres <- spotify_songs %>% group_by(playlist_subgenre)

average_minutes <- subgenres %>% summarize("avg_min"=mean(duration_ms)/1000/60)

average_minutes

average_minutes %>% filter(avg_min==max(average_minutes$avg_min))

```
On average, "New Jack Swing" subgenre has the longest song.

### 4. Make two boxplots side-by-side of the danceability of songs stratifying by whether a song has a fast or slow tempo. Define fast tempo as any song that has a tempo above its median value. On average, which songs are more danceable?

```{r boxplots}

# Step 1: Categorize the data into fast or not
    spotify_songs <- spotify_songs %>%
     mutate(is_fast = case_when(
                    tempo > median(tempo) ~ "Yes",
                    tempo <= median(tempo) ~ "No"
            ))
    
    ## Check to make sure that the categorization into tempo categories was performed          properly:
    
    median(spotify_songs$tempo)
    
    spotify_songs$tempo[1:5]
    
    spotify_songs$is_fast[1:5]
    
    ## Yes!

# Step 2: Generate box-plots of danceability of the songs stratified by groups:
    
    spotify_songs %>% ggplot(aes(x=is_fast, y=danceability)) + geom_boxplot(fill="forest green") + labs(title="Danceability versus Tempo Categories")



```

Surprisingly, slower songs tend to be more danceable on average. 

# Part 2: Convert nontidy data into tidy data

## 1. Select only unique distinct rows from the dataset based on the track_name and track_artist columns (Hint check out the distinct() function in dplyr).

```{r unique}

distinct_songs <- spotify_songs %>% distinct(track_name, track_artist, .keep_all = TRUE)

```

## 2. Add a new column called year_released listing just the year that the song was released. (Hint check out the ymd() function in lubridate R package. Also, if you get a warning message with “failed to parse”, check out the truncated argument in the ymd() function.).

```{r year released}

distinct_songs$track_album_release_date <- ymd(distinct_songs$track_album_release_date, truncated = 2)


distinct_songs <- distinct_songs %>% mutate(year_released = year(distinct_songs$track_album_release_date))

```

## 3. Keep only songs that were released in or after 1980.

```{r keep songs}

after1980 <- distinct_songs %>% filter(year_released >= 1980)

```

## 4. Add a new column with the duration of the song in minutes

```{r}

after1980 <- after1980 %>% mutate(duration_min = duration_ms/1000/60)

after1980$duration_min[1:5]
```

## 5. For each year_released, calculate the mean of at least 6 of the audio features (e.g. danceability, energy, loudness, etc), or descriptors (e.g. tempo, duration in minutes, etc). (Hint: If all has gone well thus far, you should have a dataset with 41 rows and 7 columns).

```{r mean of audio}
after1980 <- after1980 %>% group_by(year_released) %>% summarize(danceability = mean(danceability), energy = mean(energy), loudness = mean(loudness), speechiness = mean(speechiness),acousticness = mean(acousticness), liveness = mean(liveness))
                        
after1980

```

## 6.Convert this wide dataset into a long dataset with a new feature and mean_score column

```{r convert to long}

after1980 <- after1980 %>% pivot_longer(-year_released, names_to = "feature", values_to = "mean_score")

after1980

```
# Part 3: Data Visualization





